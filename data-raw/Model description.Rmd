---
title: "Model description"
output:
 html_document:
   toc: true
   toc_depth: 5
   toc_float: true
date: "2024-09-23"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  echo = FALSE,
  message = FALSE,
  warning = FALSE,
  scipen=999,
  cache.extra = 3
)
library(tidyverse)

library(here)
devtools::load_all(".")
internal_data<-list()

```

# Disclaimer

 
<p style="color:red">**This document does not represent agency policy position nor management decision, has not been endorsed by any agency, and should not be interpreted as such.**</p>


# Overview

This document describes my process of developing a simulation model for the purpose of informing decisions about harvest management strategies for the Summer Chinook management stock in the Columbia River. That simulation model can be accessed [here](https://marksorel.shinyapps.io/Summer_Chinook_simulator/). Underlying code can be accessed [here](https://github.com/marksorel8/Sumsimmer).

Broadly, the simulation is built around Ricker stock-recruit models for the three primary natural populations (Wenatchee, Methow, and Okanogan), and a single stock-recruit model for the production of all hatchery-origin fish that return during the summer Chinook managment period. The model has several other components including, return ages of fish, ocean harvest, terminal harvest, hatchery-origin spawning, and hatchery broodstock collection. 

# Run reconstruction

The stock-recruit models characterize the productivity of the populations in the absence of fishing mortality. Therefore, the first step is to reconstruct "recruits", or the number of adult fish that would have returned to their spawning grounds in the absence of fishing. To do this, I started with observed escapement to the three natural-origin populations, and expanded those based on fishing mortality in the Columbia River and the ocean. The hatchery run reconstruction was a little different. I subtracted the natural-origin returns to the Columbia River mouth from the total TAC river mouth run size to get an estimate of hatchery returns to the Columbia river mouth during the summer management period. I then expanded those based on ocean fishing mortality to get hatchery recruits. Details on the run reconstruction are provided below.

### Data

The data used in this run reconstruction are as follows:  

- **Natural-origin spawners and natural-origin broodstock removals** from [WDFW's SPI database](https://data.wa.gov/dataset/WDFW-Salmonid-Population-Indicators-Database-SPI-M/x25s-cxg8/about_data), and Okanogan broodstock removals from the Colville Tribes (Andrea Pearl, pers. comm.).  
- **Wild carcass age composition ** from WDFW (Katy Shelby, pers. comm.) for Wenatchee and Methow, and Colville Tribes (Andrea Pearl, pers. comm.) for Okanogan.  
- **River mouth run size by age** during the summer management period from TAC.  
- **Unmarked harvest rate** within the Columbia River from information in TAC BA tables and calculated by me (Mark Sorel, pers. comm.).  
- **Ocean exploitation rates** from the Chinook Technical Committee (CTC) [exploitation rate analysis](https://www.psc.org/wp-admin/admin-ajax.php?juwpfisadmin=false&action=wpfd&task=file.download&wpfd_category_id=35&wpfd_file_id=15444&token=&preview=1). These include US and Canadian ocean fisheries from SE Alaska to Oregon.  
```{r data, cache = TRUE}

# escapement estimates, pHOS, Broodstock removals from SPI database
wa.esc <- read_csv("https://data.wa.gov/resource/fgyz-n3uk.csv?$query=SELECT%20stock_number%2C%20population_name%2C%20sub_population_name%2C%20data_series_num%2C%20species%2C%20year%2C%20abundance_qty%2C%20data_type%2C%20production_type%2C%20calculation_type%2C%20escapement_methodology%2C%20escapement_methodology_desc%2C%20biologist_methodology_desc%2C%20comments%2C%20report_types%2C%20last_update%20WHERE%20%60population_name%60%20IN%20('Methow%20Summer%20Chinook'%2C%20'Okanogan%20Summer%20Chinook'%2C%20'Wenatchee%20Summer%20Chinook')")

# data on natural-origin carcass ages and natural origin broodstock removal in Okanogan
ok_dat<-readxl::read_xlsx(here::here("data-raw/data/Okanogan_Sum_Chk_data_1998-2023_MSorel.xlsx"))

# data on natural-origin carcass ages in Methow and Wenatchee
age_dat<-readxl::read_xlsx(here::here("data-raw/data/UC_SUCH_Escapement_Age_Exploitation_4Thomas.xlsx"),skip=1) |> filter(Basin!="Okanogan") |> bind_rows(ok_dat |> mutate(Basin="Okanogan"))

# preterminal survival from fisheries based on CTC exploitation rate analysis
# MREER<-read_csv("data/CTC_ERA_MREER.csv")
PreTermSurv<-read_csv(here::here("data-raw/data/CTC_ERA_sum_chk_preTermSurv.csv"))

# estimates of unmarked exploitation rate derived from TAC BA tables by me (mark)
term_ER<-readxl::read_xlsx(here::here("data-raw","data","Terminal_summer.xlsx"),sheet="term_UM_er")

above_bon_HR<-readxl::read_xlsx(here::here("data-raw","data","Terminal_summer.xlsx"),sheet="Sheet1",range="A1:m256") |>
  filter(Fishery %in%c("Zone 6 Sport","Zone 6 Treaty Total","McN-PRD Sport","Wanapum","Above PRD Sport","Colville")) |>
  group_by(Year) |>
  summarize(above_bon_HR=sum(UM_HR_aboveBon))

URR<-readxl::read_xlsx(here::here("data-raw","data","Terminal_summer.xlsx"),sheet="Sheet1",range="A1:m256") |>
  filter(Fishery !="Zone 6 Treaty Total") |>
  group_by(Year) |>
  summarize(URR=weighted.mean(URR,Handle))


# conversion rates from Bonneville to Rock Island from DART
conv_rate<-read_csv(here::here("data-raw/data/pitconrate_1716318730_518.csv"),n_max=11)

# conv_rate |> select(Year=ObservationYear,meanConRate)  |> 

# Mgmt stock
tac_RR<-readxl::read_xlsx(here::here("data-raw/data/SummerChinook.xlsx"))

# hatchery releases from RMIS database
# devtools::install_github("Ben-Cox/rRMIS")
library(rRMIS)
releases<-get_release_data(first_by=1987, last_by=2023)


## FRAM PFMC AEQ Fishery Year morts

pfmc_morts<-readxl::read_xlsx(here::here("data-raw/data/New Summer Chinook Reconstruction  101023.xlsx"),sheet="TotalRunSize",skip=2,n_max = 45) |> 
  filter(Year>=2008) |> rename(`PFMC NT Harvest Total`=`PFMC NT Ocean Impacts`)


pfmc_HRs<-readxl::read_xlsx(here::here("data-raw/data/New Summer Chinook Reconstruction  101023.xlsx"),sheet="TotalHarvestRates",skip=2,n_max = 45) |> 
  filter(Year>=2008)
```


```{r MREER_interp, include=FALSE,cache=TRUE}
#interpolate a few missing ocean exploitation mortality rates.
PreTermSurv_mod<- PreTermSurv|> 
  ungroup() |> mutate(logit_surv=qlogis(ifelse(PretermSurv==1,.99,PretermSurv)),
                      CY_fac=as.factor(CY),
                      const=as.factor("const"),
                      Age=factor(Age,ordered = is.ordered(Age)),
                      CY_scale=c(scale(CY)))|> filter(CY<=2023) ##|> filter(between(CY,1978,2021))


PreTermSurv_mod |> ggplot(aes(x=CY,y=logit_surv))+geom_point()+geom_line()+facet_wrap(~Age)+theme_minimal()


# prep Z-scored alr 0ge prop MARSS
wide_surv<-PreTermSurv_mod |> select(CY ,Age,logit_surv) |> 
  pivot_wider(values_from =logit_surv ,names_from = c(Age)) |> 
  arrange(CY) |> 
  filter(CY<=2023) |>
  select(-CY) |> 
  as.matrix() |>  
  apply(2,scale) |> 
  t() 


rownames(wide_surv)
#-----------------------------------------------
### DFA
ns<-nrow(wide_surv)
n_fac<-5

B <- matrix(list(0), n_fac, n_fac)

diag(B)<-c("b",list(1),1,1,1)

Q <- diag(1, n_fac)

R <- "diagonal and unequal"

U <- "zero"
x0 <- "zero"
A <- "unequal"
V0 <- diag(5, n_fac)
Z <- matrix(list(0), ns, n_fac)
Z[1:(ns * n_fac)] <- paste0(rep(paste0("z",1:n_fac),each=ns),rep(1:ns,times=n_fac))

Z[upper.tri(Z)]<-0
diag(Z)[2:5]<-.2
Z[3:5,2]<-0
Z[4:5,3]<-0
Z[5,4]<-0



D<-"diagonal and unequal"
d<-t(apply(matrix(1:ncol(wide_surv),nrow(wide_surv),ncol(wide_surv),byrow = TRUE), 1,scale))





mod.list.dfa_MREER = list(B = B, Z = Z, Q = Q, R = R, U = U, A = A, 
                          x0 = x0,V0=V0,tinitx=1,d=d,D=D)




library(MARSS)
fit.dfa.surv <- MARSS(wide_surv, model = mod.list.dfa_MREER, control = list(maxit = 500),
                      inits = list(A = matrix(0, ns, 1)))


pre_turm_surv_scales<-PreTermSurv_mod |>  #filter(between(CY,1986,2021)) |> 
  group_by(Age) |> summarise(mu=mean(logit_surv,na.rm=T),sd=sd(logit_surv,na.rm=T))


PreTermSurv_mod2<-t(fit.dfa.surv$ytT*pre_turm_surv_scales$sd+pre_turm_surv_scales$mu)|> `colnames<-`(rownames(wide_surv)) |> as_tibble() |>  mutate(cy=1973:2023) |> pivot_longer(-cy,names_to = "Age",values_to = "logit_surv") |> mutate(age=as.numeric(substr(Age,4,4)),by=cy-age) |> 
  arrange(by,Age) |> 
  group_by(by) |> mutate(n=n(),MREER=1-cumprod(plogis(logit_surv))) |> 
  filter(n>=age-1) |> 
  ungroup()


sim_surv_mod<-fit.dfa.surv

sim_surv_mod$marss$fixed$x0[,,1]<-sim_surv_mod$states[,dim(sim_surv_mod$states)[2]]
for( i in 1:5){
  sim_surv_mod$marss$free$A[i,i,]<-mean(tail(sim_surv_mod$marss$free$A[i,i,],10))
}
# sim_surv_mod$par$Z[6:9,]<-0

sim_surv_mod$marss$fixed$Z[,,]<-0

sim_MREER<-MARSS::MARSSsimulate(sim_surv_mod,tSteps = 51,1)$sim.data



sim_MREER<-t((cbind(fit.dfa.surv$ytT,sim_MREER[,,1])*pre_turm_surv_scales$sd+pre_turm_surv_scales$mu))|> `colnames<-`(rownames(wide_surv)) |> as_tibble() |>  mutate(cy=seq(from=1973,by=1,length.out=102)) |> pivot_longer(-cy,names_to = "Age",values_to = "logit_surv") |> mutate(age=as.numeric(substr(Age,4,4)),by=cy-age) |> 
  arrange(by,Age) |> 
  group_by(by) |> mutate(n=n(),MREER=1-cumprod(plogis(logit_surv))) |> 
  filter(n>=age-1) |> 
  ungroup() 


sim_MREER |> ggplot(aes(x=by,y=MREER))+geom_point()+facet_wrap(~Age)+geom_line()+geom_vline(aes(xintercept=2022))+theme_minimal()


```

### Calculations

#### Natural-origin escapement

I begin by calculating natural-origin *Escapement* as the sum of spawners and fish taken for broodstock. 

$$ Escapement_y = Spawners_y + Broodstock_y$$
where $y$ represents the year.


```{r escapement, fig.cap="Figure 1. Annual natural-origin escapement by population."}

#escapement
esc_dat<-
  #SPI data
  wa.esc %>% filter(population_name %in% c("Wenatchee Summer Chinook","Methow Summer Chinook","Okanogan Summer Chinook")) %>% 
  
  mutate(abundance_qty =as.numeric(abundance_qty ),
         data_type=case_when(population_name!="Okanogan Summer Chinook"~data_type,
                             escapement_methodology=="Total Natural Spawners"~"TSAIJ",
                             escapement_methodology%in%c("NOSAIJ","Natural-Origin Spawners")~"NOSAIJ",
                             escapement_methodology%in%c("HOSAIJ","Hatchery-Origin Spawners")~"Spawner Fish",
                             TRUE~escapement_methodology
         ),
         year=as.numeric(year)) %>%  
  pivot_wider(id_cols = c(year,population_name),values_from =abundance_qty,names_from = data_type) %>% 
  mutate( #ts_test=NOSAIJ+`Spawner Fish`,
    # phos_test=`Spawner Fish`/TSAIJ,
    total_spawners=ifelse(is.na(TSAIJ),`Spawner Fish`+NOSAIJ,TSAIJ),
    NOS=ifelse(is.na(NOSAIJ),total_spawners,NOSAIJ),
    HOS=total_spawners-NOS,
    PHOS=HOS/total_spawners
  ) %>% arrange(population_name,year) %>% ungroup %>% mutate(population_name=stringi::stri_extract_first_words(population_name)) |>
  #add auxiliary okanogan broodstock removal data from Andrea
  left_join(ok_dat |> select(year=`Spawn Year`,NOBroodStockRemoved2=NO_broodstock_removed ) |> mutate(population_name="Okanogan")) |> 
  #prior to 2012, the estimate of brodstock collection for the Methow include both Methow and Okanogan (collecitona tWells Dam). Goin to apportion the removals based on natural_origin spawning escapement.
  
  mutate(pop_group=ifelse(population_name=="Wenatchee","Wenatchee","OkMet")) |> 
  group_by(year,pop_group) |> 
  mutate(NOBroodStockRemoved=case_when(population_name=="Wenatchee"~NOBroodStockRemoved,
                                       population_name=="Methow"&year>=2012~NOBroodStockRemoved,
                                       population_name=="Okanogan"&year>=2012~NOBroodStockRemoved2,
                                       TRUE~(NOS/sum(NOS))*sum(NOBroodStockRemoved,na.rm=T)
  ),
  ) |> select(-c(NOBroodStockRemoved2)) |> 
  ungroup() |> 
  mutate(NOR = NOS + replace_na(NOBroodStockRemoved,0)) |> 
  left_join(age_dat |> select(population_name=Basin,year=`Spawn Year`,`SG No. Age 2`:`SG No. Age 6`,pNOB) ) |> 
  mutate(PHOS=pmax(PHOS,0),
         pNOB=replace_na(pNOB,1),
         pNI=pNOB/(pNOB+PHOS)) |> 
  group_by(population_name) |> 
  arrange(year) |> 
  mutate(pNI_bar=lag(zoo::rollmean(pNI,10,fill=1,align="right"),4)) |> 
  filter(year>=1989)




esc_dat %>% filter(!is.na(`SG No. Age 4`)) |> select(year,population_name ,Spawn=NOS,Broodstock=NOBroodStockRemoved) %>%
  drop_na() |> pivot_longer(c(Spawn,Broodstock),values_to = "NO_Return") %>% ggplot(aes(x=year,y=NO_Return,fill=name))+geom_bar(stat="identity")+facet_wrap(~population_name,scales="free_x")+theme(legend.position = "right")+ylab("Nat. Origin Escapement")+theme_minimal()


long_dat<-esc_dat |> select(spawn_year=year,basin=population_name,NOR,`SG No. Age 2`: `SG No. Age 6`) |> drop_na() |> 
  pivot_longer("SG No. Age 2" :"SG No. Age 6" ,names_to = "age",values_to = "n_carcs") |> mutate(age=as.numeric((substr(age,12,12))),brood_year=spawn_year-age) |> 
  #add terminal HR
  left_join(term_ER |> rename(spawn_year=Year)) |> 
  #add ocean MREER
  left_join(sim_MREER |> 
              mutate(age=as.numeric(substr(Age,4,4))) |> 
              select(brood_year=by,age,MREER)) |> 
  group_by(basin,spawn_year) |> 
  mutate(spawn_year_age_prop=proportions(n_carcs),
         NO_returns=NOR*spawn_year_age_prop,
         NO_river_mouth=(NO_returns/(1-term_UM_HR)),
         NO_recruits=(NO_river_mouth/(1-MREER)))


#write a file of the no returns to river mouth to use to evaluate the ability to forecast that
write.csv(long_dat,"long_dat.csv")
long_dat |> ungroup() |>  group_by(brood_year,age) |> summarise(n=length(NO_river_mouth),NO_river_mouth=sum(NO_river_mouth)) |> 
  filter(n==3) |> pivot_wider(names_from = age,values_from = NO_river_mouth) |>
  write_csv("NO_river_mouth.csv")

```


I multiply the carcass age proportions by the escapement to calculate escapement by age.

$$Escapement_{a,y}=Escapement_y*p^{escapement~age}_{a,y}$$

```{r esc_age, fig.cap="Figure 2. Annual proportions of carcasses of different ages recovered on the spawning grounds."}


long_dat |>  mutate(age=factor(age,levels=6:2)) |> 
  ggplot(aes(x=spawn_year,y=spawn_year_age_prop ,fill=age)) +
  geom_col() +
  facet_wrap(~basin)+ylab("Escapement age props")+theme_minimal()

```



#### Natural-origin recruits

I expand the escapement based on the terminal harvest rate and ocean exploitation rate to calculate an estimate of recruits. 

$$ Recruits_{a,y} = \frac{Escapament_{a,y} } {(1- terminal~ HR_y)*(1- Ocean~ ER_{a,y})} $$

##### Terminal harvest
I used information on harvest of marked and unmarked fish from the TAC BA tables to calculate annual harvest rates on unmarked fish as best I could. We (TAC) should make efforts to include the mark status of kept and released fish in our files as best as possible moving forward. I assumed that the terminal harvest rate was the same for all age classes within a given year. These estimates assume that the TAC estimates of fishing mortality during the summer management period are representative of the fisheries mortality of the summer Chinook run, however,  [roughly ~20% of the PIT-tagged upper Columbia summer Chinook pass Bonneville Dam prior to June 16](https://www.cbr.washington.edu/dart/query/pitadult_hrt).This adds some error to the modeling, which could be accounted for in the future. 


```{r term_HR, fig.cap="Figure 3. Terminal harvest rate estimates for unmarked Chinook during the summer managment period, as well as the for the total stock (marked and unmarked). The unmarked harvest rate was used to expand escapement to an estimate of natural-origin recruits to the Columbia River mouth"}

term_ER |> pivot_longer(c(term_UM_HR:Tot_HR),names_to="Mark", values_to = "HR") |>
  mutate(Mark=case_when(
    Mark=="term_M_HR"~"Marked",
    Mark=="term_UM_HR"~"Unmarked",
    TRUE~"Total"
  )) |>
  filter(Mark!="Marked") |> 
  ggplot(aes(x=Year,y=HR,color=Mark))+geom_point()+geom_line()+ylab("Columbia River harvest rate")+theme_minimal()


```

##### Ocean exploitation

For ocean exploitation rates, I used what the CTC calls Mature Run Exploitation Rates (MREERs), which is the the proportional reduction in terminal returns in given year due to fishing mortality in the current and past years. The CTC produces estimates of MREER for two Upper Columbia indicator stocks -- Wells Hatchery and Similkameen and Omak Pond -- and I used a weighted mean of the values for these stocks, where the weighting was by their escapement. I used age-specific MREER estimates when calculating estimates of recruits of each age in each year. 


```{r MREER_plot, fig.cap="Figure 4. Annual Mature Run Exploitation Rate, which is the proportional reduction in returns to the Columbia River mouth in a given year due to ocean fisheries in the current and previous years. Age-specific estimates were used in the run reconstruction, but the total annual rate based on the TAC river-mouth age proportions is shown here for simplicity."}

tac_RR |> pivot_longer(Age3:Age6,names_to="Age",values_to="riv_mouth") |>
  mutate(age=as.numeric(substr(Age,4,4)),
         year=BroodYear+age) |> group_by(year) |>
  left_join(sim_MREER |> select(year=cy,Age,MREER)) |>
  summarize(n=n(),mreer=weighted.mean(MREER,riv_mouth)) |> drop_na() |>  
  ggplot(aes(x=year,y=mreer))+
  geom_point()+geom_line()+ylab("Ocean ER")+xlim(1989,2022)+theme_minimal()+ylim(0,1)

```

#### Hatchery-origin recruits

My approach to estimating hatchery-origin recruits was to 

1) reconstruct the natural-origin river mouth run size and subtract that from the TAC river mouth run size to get the hatchery-origin river mouth run size for the summer Chinook management period,
2) expand the hatchery river mouth run size by the same age-specific ocean MREER described above to get hatchery-origin recruits. 

$$Hatchery~recruits_{a,y} = \frac{RMRS{a,y}-RMRS^{\text{natural}}_{a,y}}{1- Ocean~ ER_{a,y}}$$
As an estimate of the natural-origin river mouth run size, I used the estimate of natural-origin recruits to the Columbia River mouth (i.e., $escapment/(1- terminal~ HR)$) summed across the three natural populations. In other words, I assumed that 1) harvest mortality was the only source of mortality contributing to the conversion rate between the river mouth and 2) all natural-origin summer Chinook pass Bonneville during the summer Chinook managment periods. I made this decision both for simplicity and the following reasons. Conversion rates of PIT-tagged wild summer Chinook between Bonneville Dam and Rock Island Dam averaged [73% in 2009--2023](https://www.cbr.washington.edu/dart/query/pitadult_conrate). Average conversion rates to McNary, Priest Rapids, and Wells Dam were all within 3% of this. In comparison, the average harvest rate of unmarked fish above Bonneville Dam in those years was `r above_bon_HR |> filter(between(Year,2009,2023)) |> summarize(mean(above_bon_HR)) |> round(2)`, so the survival was `r 1-(above_bon_HR |> filter(between(Year,2009,2023)) |> summarize(mean(above_bon_HR))) |> round(2)`. Given that the harvest rate was greater than the total mortality rate between Bonneville and Rock Island Dam, and for simplicity, I decided to use one minus the total unmarked harvest rate (Figure 3) as the conversion rate between the river mouth and escapement. Surely there is some natural-mortality as well, including between Rock Island Dam and spawning, and by not accounting for that I am underestimating the natural-origin river mouth return and overestimating hatchery-origin returns. However, we also know that [~20% of PIT-tagged summer Chinook are detected passing Bonneville prior to the summer Chinook management period](https://www.cbr.washington.edu/dart/query/pitadult_hrt). By not accounting for that, I am overestimating the natural-origin return during the summer management period (by ~20%). I hope that these two weird assumptions balance each other out to some degree. Alternative ways of modeling, which more explicitly account for natural mortality and the timing of passage within different management periods, could be evaluated in the future. 


```{r rmrs_fig,fig.cap="Figure 5. Reconstructed river mouth run size by origin and year."}
returns<-tac_RR |> pivot_longer(Age3:Age6,names_to="Age",values_to="riv_mouth") |>
  mutate(age=as.numeric(substr(Age,4,4)),
         year=BroodYear+age)|> 
  left_join(long_dat |> group_by(spawn_year,age) |> summarize(wild=sum(NO_river_mouth),n=n()) |> filter(n==3) |> rename(year=spawn_year)) |> mutate(hatchery=riv_mouth-wild) 

returns |> pivot_longer(c(wild,hatchery),names_to = "origin",values_to = "RMRS") |> ggplot(aes(x=year,y=RMRS,fill=origin))+geom_col()+ylab("River mouth run size")+xlab("")+theme_minimal()



internal_data$esc_dat<-esc_dat |> mutate(Escapement=NOS+NOBroodStockRemoved)|> bind_rows(
  
  returns |> group_by(year) |> summarize(return_h=sum(hatchery)) |> left_join(term_ER,by=c("year"="Year") ) |> mutate(escapement_H=return_h*(1-term_M_HR))  |> select(year,Escapement=escapement_H) |> drop_na()|> mutate(population_name ="Hatchery"))

```

The result of the run reconstruction is an estimate of hatchery and natural-origin recruits by age and year. The primary data time series limiting the length of the time series of reconstructed recruits is that of the escapement age composition. This could be imputed (e.g., within and integrated model) in the future, if needed .

```{r recruit_age_plot, fig.cap="Figure 6. Recruits by age, brood year, and population. Note that the y-axes differ among panels."}

all_recruit_dat<-
  returns |> select(year,Age,brood_year = BroodYear,riv_mouth,hatchery) |> left_join(sim_MREER |> select(year=cy,Age,MREER)) |>
  mutate(Recruits=hatchery/(1-MREER)) |> mutate(age=as.numeric(substr(Age,4,4)),basin="Hatchery") |> select(age,Recruits,basin,brood_year) |> bind_rows(long_dat |> ungroup() |>  select(age,Recruits=NO_recruits,basin,brood_year)) |> drop_na() |> filter(age>2) |>  group_by(brood_year,basin) |> mutate(n_ages=n()) |> ungroup() |>  filter(n_ages==4)


ggplot(all_recruit_dat |> mutate(age=factor(age,levels=6:2)), aes(x=brood_year,y=Recruits,fill=age))+geom_col()+facet_wrap(~basin,scales="free_y")+ylab("Recruits")+xlab("Brood year")+theme_minimal()
```




# Simulation model

To simulate the system I needed modules to simulate the following processes:

- Recruits as a function of spawners/broodstock
- Maturation ages of recruits
- Ocean exploitation rates
- Terminal harvest rates as a function of harvest control rules
- Broodstock collection
- Hatchery-origin spawning

![Figure. Simulation model diagram](`r here::here("data-raw/Summer chinook mgmt modeling diagram.png")`)


### Stock-recruit models

I fit Ricker spawner-recruit relationships for each natural population.
$$\text{recruits}_y=\alpha*\text{spawners}_y*\text{exp}\left(\frac{-\alpha*\text{spawners_y}}{e*\text{Rmax}}+\varepsilon_y\right)$$
where $\alpha$ represents the maximum recruits per spawner as you approach zero spawners, and $\text{Rmax}$ represents the maximum expected recruits and $e$ is Euler's number. I assumed that all populations had the same $\alpha$ but allowed $\text{Rmax}$ to differ among populations. The $\varepsilon$ term represents annual deviations from the Ricker relationship. The distribution of those deviations is described below. 


I explored different assumptions regarding the contribution of hatchery-origin spawners to production and found some data support (based on AIC) for the following model. For the per-capita contirbution of a hatchery-origin spawner I used the 10-year running average of proportionate natural influence (PNI) through the the brood year 4 years prior to the current year:

$$\text{spawners}_y = \text{NOS}_y+\overline{\text{PNI}}_y* \text{HOS}_y$$

where $\overline{\text{PNI}}_y$ is the 10-year running average of proportionate natural influence (PNI) through the the brood year 4 years prior to the current year.


```{r tot_spawners, fig.cap="Figure .Numbers of natural- and hatchery-origin spawners by year and population."}

esc_dat |> filter(!is.na(`SG No. Age 4`),year<=2023)|> select(year,basin=population_name,hatchery=HOS,wild=NOS) |> pivot_longer(c(hatchery,wild),names_to = "Origin",values_to = "Spawners")|> ggplot(aes(x=year,y=Spawners,fill=Origin))+geom_col()+facet_grid(~basin)+theme_minimal()
```

```{r PNI_plot, fig.cap="Figure . 10-year running average of the Porportional Natural Influence of hatchery programs through 4 brrod years prior to the return year on the x-axis."}

esc_dat |> filter(!is.na(`SG No. Age 4`),year<=2023)|> select(year,basin=population_name,pNI_bar) |>  ggplot(aes(x=year,y=pNI_bar))+geom_col()+facet_grid(~basin)+theme_minimal()+xlab("Return Year")+ylab("10-year PNI")

```


I fit a linear relationship between hatchery smolt releases and hatchery returns. This assumes that there is no density dependent survival after release from the hatchery. The majority of smolts have been released at the yearling lifestage. I counted subyearling releases as 0.5 of a yearling release when calculating the total number of "yearling equivalent" releases to fit the model to. 

```{r releases, fig.cap="Figure .Upper Columbia River hatchery smolt releases by lifestage and brood year.",cache=TRUE}

rel2<-releases %>%   
  filter(species==1 & run==2,rearing_type =="H",rmis_domain!="AK") |>  filter(psc_region%in%c("CECR","CRGN","UPCR","WAGN"),release_site!="QUILLAYUTE+TULALIP C",brood_year>=1987) |>
  rRMIS::releases_for_tr() |> 
  rowwise() %>% 
  mutate(mean_rel_date=mean(c(last_release_date,first_release_date)),
         age=mean_rel_date-as.Date(paste0(brood_year,"-10-01")),lifestage=ifelse(age<=400,"Sub-yearling","Yearling")) %>% 
  filter(brood_year<=2021) |>
  pivot_longer(Ad_CWT:Unclipped_NoCWT,names_to = "mark",values_to = "count") |> 
  mutate(count2=ifelse(lifestage=="Sub-yearling",count*.5,count),
         mark=ifelse(grepl("Ad",mark),"Ad","UM")) |> 
  group_by(brood_year,lifestage) |> 
  summarise(releases=sum(count),releases2=sum(count2),
            ad_releases=sum(count[mark=="Ad"]),
            ad_releases2=sum(count2[mark=="Ad"]),
            MR=ad_releases/releases
  )

rel2 |> filter(brood_year>=1995)|> ggplot(aes(x=brood_year,y=releases,fill=lifestage))+geom_col()+ylab("Smolt releases")+xlab("Brood year")+theme_minimal()

## Average mark rate
ave_MR<-rel2 |> group_by(brood_year) |> summarize(MR=sum(ad_releases2)/sum(releases2)) |> 
  filter(brood_year>=2008 &brood_year!=2019) |> summarize(mean(MR),sd(MR)) 

internal_data$hatch_MR_mu<-ave_MR$`mean(MR)`



```



```{r}

rel3<-rel2 |> filter(brood_year >=1995) |> group_by(brood_year) |> summarize(releases=sum(releases2)/1000,log_rel=log(releases)) 


rel_mod<-lm(log_rel~1,data=(rel3 |> filter(brood_year >=2000)))

# summary(rel_mod)
# AIC(rel_mod)

smolts_mu<-rel_mod$coefficients
smolts_sd<-sigma(rel_mod)


```

When simulating future hatchery production, I assumed that the geometric mean number of yearling smolt equivalents released since year 2000 (n = `r format((round(exp(smolts_mu)*1000,0)),scientific=FALSE,big.mark=",")`) would be released annually, with lognormal error (CV = `r (round(smolts_sd,2))`), as long as the hatchery-origin escapement was sufficient to provide 2,000 for broodstock, plus any broodstock that was needed to back fill for shortfalls in natural-origin broodstock collection relative to targets in conservation programs. The number of smolts released was assumed to decrease proportionally to any shortfall in hatchery escapement for broodstock.


The error terms for the three natural-origin populations and the hatchery origin population were assumed to follow a 1st order autoregressive process with multivariate-normal increments.

$$
\begin{gathered}
\varepsilon_0 \sim N(0, \Sigma) \\
\varepsilon_1 =\phi \varepsilon_0+\sigma x_1, \quad x_1 \sim N(0, \Sigma) \\
\varepsilon_y=\phi \varepsilon_{y-1}+\sigma x_i, \quad x_y \sim N(0, \Sigma)
\end{gathered}
$$
where $\varepsilon_y$ represents the vector of errors for the four populations in a given year, $\phi$ determines the degree of autocorrelation and $\sigma=1-\sqrt{\phi^2}$. The annual increments were assumed to follow a multivariate normal distribution with an unstructured covariance matrix. Thus, when simulating future recruitment from this model, I accounted for how recruitment is correlated from year to year and among populations within years.




```{r hatch_recruits_per_release,include =FALSE,cache=TRUE}
#lambert w function
W <- function(x) {
  logx <- log(x)
  y <- pmax(logx, 0)
  while (any(abs(logx - log(y) - y) > 1e-9, na.rm = TRUE)) {
    y <- y - (y - exp(logx - y)) / (1 + y)
  }
  y
}


hatch_recruits<-returns |> select(year,Age,brood_year = BroodYear,riv_mouth,hatchery) |> left_join(sim_MREER |> select(year=cy,Age,MREER)) |>
  mutate(hatch_recruits=hatchery/(1-MREER))
#combine hatchery and wild recruits per spawner/smolt 

SR_dat<-esc_dat |> select(brood_year=year,basin=population_name,total_spawners,PHOS,NOS,HOS,pNI_bar) |> right_join(
  long_dat |> group_by(basin,brood_year) |> summarise(NO_recruits=sum(NO_recruits),n=n()) |> filter(n==5,brood_year<=2017)
) |> 
  #get rid of some outliers
  filter(!(basin=="Methow"&NO_recruits>9000),
         !(basin=="Wenatchee"&NO_recruits>40000))

#|> 
# mutate(rps=NO_recruits/total_spawners,
#        year_fac=as.factor(brood_year),
#        const=as.factor(1)) |> 
# ungroup() 

# View(SR_dat)
# SR_dat |> ggplot(aes(x=total_spawners,y=NO_recruits,color=basin))+geom_point()
# SR_dat |> ggplot(aes(x=total_spawners,y=NO_recruits,color=PHOS))+geom_point()+facet_wrap(~basin)



all_SR<-  
  SR_dat |> 
  mutate(S_PNI=NOS+HOS*pNI_bar,
         S_no=NOS,
         S_ho=HOS,
         S_dummy=1) |> 
  select(basin,brood_year,S_tot=total_spawners,S_no,S_ho, S_PNI ,R=NO_recruits,PHOS,S_dummy,pNI_bar) |> 
  bind_rows(hatch_recruits |> 
              group_by(brood_year) |> 
              summarize(n=n(),hatch_recruits=sum(hatch_recruits)) |> drop_na() |> 
              left_join(rel2 |> 
                          group_by(brood_year) |> 
                          summarise(releases2=sum(releases2))) |> 
              mutate(basin="Hatchery") |> 
              mutate(releases2=releases2/1000,
                     PHOS=1,
                     S_tot=releases2,
                     S_no=releases2,
                     S_PNI=releases2,
                     S_ho=0,
                     S_dummy=1,
                     pNI_bar=0) |> 
              select(basin,brood_year,S_tot,S_no,S_ho, S_PNI,R=hatch_recruits,PHOS,S_dummy,pNI_bar) |> 
              filter(R<max(R,na.rm=T))
  ) |> 
  drop_na() 



make_TMB_data<-function(dat,spawners){
  test_mod_dat<-dat |> group_by(basin) |>
    mutate(rps=R/{{spawners}},
           lrps=log(rps),
           mu_rps=mean(lrps),
           sd_rps=sd(lrps),
           mu_s=mean({{spawners}}),
           sd_s=sd({{spawners}}),
           s_scale=c(scale({{spawners}})),
           lrps_scale=c(scale(lrps))) |>
    ungroup() |>
    mutate(year_fac=as.factor(brood_year),
           const=as.factor(1),
           s_scale=ifelse(basin=="Hatchery",0,s_scale),
           wild=ifelse(basin=="Hatchery",0,1),
           S=ifelse(basin=="Hatchery",0,{{spawners}}))
  
  col_name <- deparse(substitute(spawners))  # Convert symbol to string
  formula <- as.formula(paste("lrps~basin-1+",col_name,":basin"))
  
  mod_mat<-model.matrix(formula,data=test_mod_dat)
  
  list(
    lrps=test_mod_dat$lrps,
    R=test_mod_dat$R,
    X=mod_mat,
    err_ind=(as.numeric(test_mod_dat$year_fac))+(as.numeric(factor(test_mod_dat$basin))-1)*n_yrs,
    NOS=dat$S_no,
    HOS=dat$S_ho,
    pNI_bar=dat$pNI_bar,
    S_PNI=dat$S_PNI,
    test_mod_dat=test_mod_dat
  )
}



## begin TMB ricker model
library(RTMB)
n_yrs<-diff(range(all_SR$brood_year))+1
n_pops<-4

SR_TMB_dat<-make_TMB_data(all_SR,S_dummy)
##parameters
params<-list(
  alpha=log(c(10,rep(2,3))),
  Rmax=rep(log(50000),3),
  log_sigma=rep(-1,4),
  cors=rep(.2,6),
  err=matrix(-1,n_yrs+1,4),
  # log_R=0
  logit_rho=rep(0,4)#,
  # logit_RRS=0
)

##data
# dat<-list(
#   lrps=test_mod_dat$lrps,
#   X=mod_mat,
#   err_ind=(as.numeric(test_mod_dat$year_fac))+(as.numeric(factor(test_mod_dat$basin))-1)*n_yrs
# )

##objective function
f<-function(parms){
  RTMB::getAll(SR_TMB_dat, parms, warn=FALSE)
  
  # par_vec<-c(alpha[1],rep(alpha[2],3),0,beta) #alphas and betas
  S<-HOS*(pNI_bar)+NOS
  
  
  # alpha_vec<-exp(c(alpha[1],rep(alpha[2],3)))
  alpha_vec<-exp(alpha)
  alpha_vec2<-(X[,1:4]%*%alpha_vec)
  alpha_vec3<-alpha_vec2*S
  
  
  Rmax_vec<-c(1000000,exp(Rmax))
  Rmax_vec2<-(X[,5:8]%*%Rmax_vec)
  
  
  # x2<-matrix(0,nrow(X),ncol(X))
  # x2[,1:4]<-X[,1:4]
  # S<-(NOS+(HOS*.8))
  # for(i in 5:8){
  # x2[,i]<-X[,i]*S
  # }
  
  # pred<-X%*%par_vec #linear predictor
  
  pred<-alpha_vec3*exp(-alpha_vec3/(exp(1)*Rmax_vec2))
  # pred<-alpha_vec3/(1+alpha_vec3/Rmax_vec2) # Beverton-Holt
  
  #   
  #   alpha*Esc*exp(-alpha*Esc/(A*exp(1)*Rmax))
  
  
  rho<-plogis(logit_rho)
  adj<-sqrt(1-rho^2) # scalar from marginal to innovation error standard deviations
  sigma<-exp(log_sigma) #transformed marginal standard deviations
  
  err2<-matrix(nrow=nrow(err)-1,ncol=ncol(err))
  err2[1,]<-rho*err[1,]+adj*err[2,]
  for(i in 2:nrow(err2)){
    err2[i,]<-rho*err2[i-1,]+adj*err[i+1,]
  }
  REPORT(err2)
  
  
  pred2<-pred*exp((err2)[err_ind])
  ## Initialize joint negative log likelihood
  nll <- 0
  nll <- nll -sum(dnorm(log(R),log(pred2),.0001,log=TRUE))
  us<-unstructured(4)
  
  nll <- nll -sum(dmvnorm(err,Sigma=us$corr(cors),scale=sigma,log=TRUE))
  
  nll <- nll -sum(dnorm(logit_rho,-1,2,log=TRUE))
  
  
  
  nll
}

f(params) #test objective function 

#cosntruct model object
obj <- MakeADFun(f, params,, random=c("err"))

#optimize
fit<-TMBhelper::fit_tmb(obj,newtonsteps =2)

fit$AIC

fit_rep<-obj$report(par=obj$env$last.par.best)
#fitted paramter values
par_list<-obj$env$parList(par=obj$env$last.par.best)


alpha<-exp(par_list$alpha)
Rmax<- exp(par_list$Rmax)
beta<-alpha[2]*exp(-1)/Rmax
marg_sd<-exp(par_list$log_sigma)
rho<-plogis(par_list$logit_rho)
us<-unstructured(4)
rick_cor<-us$corr(par_list$cors)


Smsy <-(1-W(exp(1-log(alpha[2]))))/beta
# Smsy
# fit$AIC

```



```{r plot_SR, fig.cap= "Figure. Stock-recruit relationships with 95% prediction intervals and past years' observations. Vertical dashed line is at Smsy, the number of spawners for maximum sustainable yield."}
ricker_pred<-SR_TMB_dat$test_mod_dat %>% group_by(basin,const,mu_rps,sd_rps,mu_s,sd_s,wild) %>% reframe(S=seq(0,max(max(S_PNI),4000)*1.5,length.out=50)) %>%
  mutate(year_fac=factor(3000)) |> 
  left_join(
    tibble(basin=c("Hatchery","Methow","Okanogan","Wenatchee"),
           marg_sd=marg_sd)
  ) |> 
  ungroup()




ricker_pred2 <-ricker_pred |> 
  mutate(
    alpha_vec=model.matrix(const~basin-1,data=ricker_pred)%*%c(alpha),
    Rmax_vec=model.matrix(const~basin-1,data=ricker_pred)%*%c(1000000,Rmax)) |> 
  rowwise() |> 
  mutate(
    recruits=alpha_vec*S*exp((-alpha_vec*S)/(exp(1)*Rmax_vec)),
    lcl=exp(log(recruits)-1.96*marg_sd),
    ucl=exp(log(recruits)+1.96*marg_sd)
  )




##plot spawners vs recruits (more years will be available if estimate age comp through IPM)
ricker_pred2 |> ggplot(aes(x=S))+geom_ribbon(aes(ymax = ucl,ymin=lcl),fill="grey")+
  facet_wrap(~basin,scales="free")+ geom_line(aes(y=recruits),color="blue",lwd=1.25)+geom_point(data=all_SR |> mutate(S=S_tot) ,aes(y=R))+
  ylab("Recruits") +
  xlab("Spawners or 1,000 hatchery smolts released")+theme_minimal()+geom_vline(data=tibble(Smsy=c(Smsy),basin=c("Methow","Okanogan","Wenatchee")),aes(xintercept=Smsy),linetype = 2)




```




```{r  stock_recruit_tab}

tibble(population=c("Hatchery","Methow","Okanogan","Wenatchee"),"$\\alpha$"=round(alpha,2),Rmax=c(0,round(Rmax,2)),Smsy=c(2000,round(Smsy,0)),"$\\phi$"=round(rho,2),"Marginal sd"=round(marg_sd,2)) |> knitr::kable(caption = "Table 1. Mean parameter estimates for stock recruit models for each population. Smsy is the number of spawners at maximum sustainable yield. The Smsy for the hatchery population will be the broodstock target, which is about 2,000 hatchery-origin fish. *Marginal sd* is the standard deviation of the annual deviations around the relationship. Note that $\\alpha$ for the hatchery population is in terms of recruits per 1,000 yearling smolts. $\\beta$ values shown here are multiplied by 1,000 for ease of viewing.")

```



```{r  stock_recruit_corr,fig.cap="Figure . Correlation of annual recruitment errors across populations."}

corrplot::corrplot(rick_cor |> `colnames<-`(c("Hatchery","Methow","Okanogan","Wenatchee")) |> 
                     `rownames<-`(c("Hatchery","Methow","Okanogan","Wenatchee")) ,type="lower",diag=FALSE)

```


### Maturation ages

We account for correlation from year to year and among populations in recruit maturation age proportions.

We model the proportion of recruits from population $i$, brood year $y$ that would have returned at age $a$ in the absence of fisheries on the additive log scale $\gamma_{i,y,a}$ as,

$$\gamma_{i,y,a} = \mu_{i,a} + \zeta_{i,a}\eta_y+\xi_{i,y,a}$$
where $\mu_{i,a}$ is a population and age specific average, $\zeta_{i,a}$ is a population and age specific loading factor onto latent variable $\eta_y$, and $\xi_{i,y,a}$ is an idiosyncratic residual error term. 

The latent variable was allowed to be autocorrelated,
$$\eta_y \sim \mathcal{N}(\lambda \eta_{y-1},~ \varsigma)$$
like the autocorrelated residual term in the spawner-recruit model, to represent the effects of common environmental conditions on age proportions. By allowing each age and population to load onto that factor with a unique parameter $\zeta_{i,a}$, the age proportions could have positive covariance, as could result from common environmental experiences having similar affects on maturation among populations, and negative covariance, such as could occur if the older age proportions increase at the same time that the younger age proportions decrease. 

Finally, the idiosyncratic residual errors were assumed to be normally distributed with population and age specific variance,

$$\xi_{i,a,y} \sim \mathcal{N}(0,~ \theta_{i,a})$$
Maturation ages have been younger than average over that last 15 years, but I modeled it as if the maturation ages will fluctuate around the long-term average in the future.

```{r age, fig.cap="Figure. Average maturation age by broodyear."}
mat_age_dat<-long_dat |> ungroup() |> 
  select(basin,brood_year,age,recruits=NO_recruits) |> 
  bind_rows(hatch_recruits |> 
              mutate(basin="Hatchery",age=as.numeric(substr(Age,4,4))) |> 
              select(basin,brood_year,age,recruits=hatch_recruits) |> 
              drop_na()) |> 
  #combine ages 2 and 3
  mutate(jack=ifelse(age<=3,"jack",age)) |> 
  group_by(basin,brood_year,jack) |> 
  mutate(recruits=sum(recruits)) |> 
  filter(age>=3) |> ungroup() |> select(-jack) |> 
  group_by(basin,brood_year) |> 
  mutate(by_props=proportions(recruits),n=n()) |> 
  filter(n==4)

# mat_age_dat |>  mutate(age=factor(age,levels=6:3)) |>
#   ggplot(aes(x=brood_year,y=by_props,fill=age)) +
#   geom_col() +
#   facet_wrap(~basin)+ylab("Recruit age props")+theme_minimal()


mat_age_dat |>  group_by(basin,brood_year) |>
  mutate(mean_age=sum(age*by_props)) |> ggplot(aes(x=brood_year,y=mean_age))+geom_point()+geom_line()+facet_wrap(~basin)+geom_smooth()+theme_minimal()+ylab("Average maturation age")+xlab("Brood year")

```



```{r age_sim_mod,include=FALSE,cache=TRUE}
#-------------------------------------------
# modeling additive log ratios of age

mat_age_dat_mod <-
  mat_age_dat |> 
  mutate(log_prop=ifelse(by_props==0,log(.001),log(by_props)),
         age_fac=as.factor(age),
         by_fac=as.factor(brood_year),
         by_scale=c(scale(brood_year)),
         const=as.factor("const"),
         missing=is.na(by_props)
  ) |> 
  group_by(age,basin) |> 
  mutate(scale_log_prop=c(scale(log_prop))) |> 
  ungroup()





# prep Z-scored alr age prop MARSS
wide_age<-mat_age_dat_mod |> select(brood_year,scale_log_prop,basin,age) |> ungroup() |> 
  filter(brood_year<=2017) |> 
  arrange(basin,age) |> 
  pivot_wider(values_from =scale_log_prop ,names_from = c(basin,age)) |> 
  arrange(brood_year) |> 
  select(-brood_year) |> 
  as.matrix() |> 
  t()

rownames(wide_age)
#-----------------------------------------------
### DFA
ns<-nrow(wide_age)
n_fac<-1

B <- matrix(list(0), n_fac, n_fac)
diag(B)<-paste0("b",1:n_fac)

# diag(B)[2:5]<-list(0)
Q <- diag(1, n_fac)
# Q<-"diagonal and unequal"
R <- "diagonal and unequal"
# R<-matrix(list(0), ns, ns)
# diag(R)<-rep(c("m","o","w","h"),each=4)
U <- "zero"
x0 <- matrix(list(0),1,1)
A <- "unequal"
V0 <- diag(5, n_fac)
Z <- matrix(list(0), ns, n_fac)
Z[1:(ns * n_fac)] <- paste0(rep(paste0("z",1:n_fac),each=ns),rep(1:16,times=n_fac))

Z[upper.tri(Z)]<-0



mod.list.dfa = list(B = B, Z = Z, Q = Q, R = R, U = U, A = A, 
                    x0 = x0,V0=V0,tinitx=1)




library(MARSS)
fit.dfa <- MARSS(wide_age, model = mod.list.dfa, control = list(maxit = 500),
                 inits = list(A = matrix(0, ns, 1)))


mat_age_scales<-mat_age_dat_mod |> group_by(basin,age) |> summarise(mu=mean(log_prop),sd=sd(log_prop))
mat_age_scales$sd[mat_age_scales$sd>.75]<-.75


sim_mod<-fit.dfa

sim_mod$marss$fixed$x0[,,1]<-sim_mod$states[,dim(sim_mod$states)[2]]

```

```{r age_sim_fig,fig.cap="Figure. One random simulated time series of recruit age proportions for brood years 2018-2067.The years through 2017 are the observed age proportions."}

test<-MARSS::MARSSsimulate(sim_mod,tSteps = 50,1)$sim.data

sim1<-(cbind(fit.dfa$ytT,test[,,1])*mat_age_scales$sd+mat_age_scales$mu) |> t() |> `colnames<-`(rownames(wide_age)) |> 
  as_tibble() |>
  rowid_to_column("year") |> 
  pivot_longer(-year,names_sep="_",names_to=c("basin","age"),values_to="alr") |> 
  group_by(year,basin) |> 
  mutate(by_props=exp(alr)/sum(exp(alr))) |> 
  mutate(age=factor(age,6:3))|> mutate(brood_year=year+(min(mat_age_dat_mod$brood_year))-1)



sim1 |> filter(brood_year>2017) |> bind_rows(mat_age_dat |> mutate(age=as.factor(age)) |> filter(brood_year<=2017)) |> 
  ggplot(aes(x=brood_year,y=by_props,fill=age)) +
  geom_col() +
  facet_wrap(~basin)+ylab("Recruit age props")+geom_vline(aes(xintercept=2018))+theme_minimal()




```

```{r mat_age_corr}
# age_Z<-matrix(0,nrow=16,ncol=17)
# age_Z[,1]<-c(sim_mod$par$Z)
# for(i in 2:17)age_Z[i-1,i]<-sim_mod$par$R[i-1]
# age_cor<-cov2cor(age_Z%*%t(age_Z))
# colnames(age_cor)<-rownames(wide_age)
# rownames(age_cor)<-rownames(wide_age)
# corrplot::corrplot(age_cor,type ="lower",diag=FALSE)

```

### Ocean exploitation

Similarly to age proportions, I modeled annual and age-specific ocean fisheries mortality allowing for correlation among successive years as well as among ages within years. 

I assumed that the ocean exploitation would be similar to the most recent 10 years, and will not return to the consistently higher explotation rates observed prior to the 1990s. 


```{r mreer_sim, fig.cap="Figure. Mature run exploitation rates (MREER) by age and brood year. The years to the left of the vertical black line are observation and the years to the right are one random simulation of future ocean fishing exploitation." }

#see the 3rd code chunk entitled "MREER_interp" for details of modeling and simulation

sim_MREER |> ggplot(aes(x=by,y=MREER))+geom_point()+facet_wrap(~Age)+geom_line()+geom_vline(aes(xintercept=2022))+theme_minimal()
```


### Terminal harvest

In the 2019--2028 USvOR Management Agreement, total allowable catch is determined based on the River Mouth Run Size plus the Adult Equivalent (AEQ) mortalities from PFMC fisheries during the calendar year. 

#### PFMC AEQ

```{r PFMC}

pfmc_mort_dat<-
  pfmc_morts |> left_join(pfmc_HRs |> select(Year,`PFMC NT Ocean Impacts`)) |> filter(Year>=2010) |> select(Year,`River Mouth Run Size`,`PFMC NT Harvest Total`,`PFMC NT Ocean Impacts`) |> rename(RMRS=`River Mouth Run Size`,PFMCNT=`PFMC NT Harvest Total` ) |> 
  mutate(run_size=RMRS+PFMCNT)

#lognormal error model

pfmc_mod_fun<-function(par){
  -sum(dnorm(log(par[1]*pfmc_mort_dat$RMRS),log(pfmc_mort_dat$PFMCNT),exp(par[2]),log=TRUE))
}

pfmc_mod_fit<-optim(c(c(.06),0),pfmc_mod_fun)

RMRS<-seq(1,150000,by=10000)
```

We model the AEQ mortalities in PFMC fisheries as a proportion of the River Mouth Run Size with log-normal error. On average from 2010-2021, the PFMC AEQ mortalities were `r round(pfmc_mod_fit$par[1]*100,1)`% of the RMRS, with `r round(exp(pfmc_mod_fit$par[2])*100)`% average inter-annual variability.


```{r , fig.cap="Figure. PFMC AEQ mortalities vs. river mouth run size. The line and shaded area represent the mean and 95% prediction intervals. The points represent observations (from TAC run-reconstruction files) from 2010--2021."}
tibble(RMRS=RMRS,fit=pfmc_mod_fit$par[1]*RMRS) |> mutate(
  lwr=fit*exp(-1.96*exp(pfmc_mod_fit$par[2])),
  upr=fit*exp(1.96*exp(pfmc_mod_fit$par[2]))
) |> ggplot(aes(x=RMRS))+geom_ribbon(aes(ymin = (lwr),ymax=(upr)),fill="grey")+geom_line(aes(y=(fit)))+geom_point(data=pfmc_mort_dat,aes(y=PFMCNT))+theme_minimal()+ylab("PFMC AEQ")+xlab("River mouth run size")

```

#### In-river harvest

I implemented two different options for simulating in-river harvest  as a function of what is allowed. 

1. The default model (top row of plots below) assumes that total harvest has a linear relationship with allowed harvest in log space. Both the allowed and the realized include the PFMC AEQ mortalities. The 2019 fishery was removed when fitting this model due its outsized effect on the residual error standard deviation. 

2. Since 2008, both sectors have been more likely to exceed their allowable take when it is small. The most dramatic example of this was the 2019 non-Treaty in-river fishery. Not fully understanding whether this will be a persistent pattern that goes into the future, I developed an alternative model (bottom row of figure below) where the average realized harvest rate is constant below a certain threshold of allowed harvest. This model would reflect a world where harvest is not responsive to what is allowed below a certain threshold.

```{r in_river_harv, fig.cap="Figure . Relationships between alllowed and realized harvest. Blue lines are the 1:1, red lines are the mean relationship, grey shaded areas span 95% prediction intervals, and points are estimates from 2008-2022. The pink diamond points represent 2019. The top row represents the default model used for simulation, where there is a log-log relationship between allowed and realized total harvest (including PFMC AEQ ocean morts). The second row is an alternative model where there is a segmented relationship between the allowed and realized in-river harvest rate (excluding PFMC)."}
pfmc_morts_2<-pfmc_morts |> dplyr::select(`Allowed Treaty or NT Harvest`,`PFMC NT Harvest Total`,`Total In-river NT`,`Total Treaty`,`Total NT`,RMRS=`River Mouth Run Size`,Year) |> pivot_longer(c(`Total Treaty`,`Total In-river NT`),values_to = "In_river_harvest",names_to = "Sector") |>
  mutate(Allowed_in_river=ifelse(Sector=="Total In-river NT",`Allowed Treaty or NT Harvest`-`PFMC NT Harvest Total`,`Allowed Treaty or NT Harvest`),
         Total_harvest=ifelse(Sector=="Total Treaty",In_river_harvest,`Total NT`))|> filter(In_river_harvest>0) |> 
  mutate(Sector=ifelse(Sector=="Total Treaty","Treaty","NT"))|>
  mutate(HoA=In_river_harvest/Allowed_in_river,
         in_river_HR=In_river_harvest/(RMRS),
         in_river_allowed_HR=Allowed_in_river/(RMRS),
         HoA_HR=in_river_HR/in_river_allowed_HR) |> 
  rename(total_allowed=`Allowed Treaty or NT Harvest`)

#save to internal data for plotting
internal_data$pfmc_morts_2<-pfmc_morts_2


in_riv_mod<-glmmTMB::glmmTMB(log(Total_harvest)~Sector:log(total_allowed)-1+diag(0+Sector|Year),data=pfmc_morts_2 |> filter(Year!=2019),dispformula = ~0)


# summary(in_riv_mod)
# AIC(in_riv_mod)
# plot(in_riv_mod)


in_riv_pred<-data.frame(total_allowed=rep(seq(1,70000,1000),times=2), Sector=rep(c("NT","Treaty"),each=70),Year=1)

pred<-predict(in_riv_mod,newdata=in_riv_pred,allow.new.levels=TRUE)

in_riv_pred$pred=exp(pred)
in_riv_pred$lcl=exp(pred-1.96*ifelse(in_riv_pred$Sector=="NT",exp(in_riv_mod$fit$par[3]),exp(in_riv_mod$fit$par[4])))
in_riv_pred$ucl=exp(pred+1.96*ifelse(in_riv_pred$Sector=="NT",exp(in_riv_mod$fit$par[3]),exp(in_riv_mod$fit$par[4])))


mod1_plot<-in_riv_pred |> 
  ggplot(aes(x=total_allowed))+geom_ribbon(aes(x=total_allowed,ymax = ucl,ymin=lcl),fill="grey")+geom_line(aes(y=pred),lwd=1.25,color="firebrick4")+geom_point(data=pfmc_morts_2,aes(y=Total_harvest))+geom_abline(intercept=0,slope=1,lwd=.8,col="blue")+facet_wrap(~Sector)+xlab("Total allowed harvest")+ylab("Total harvest")+theme_minimal()+geom_point(data=pfmc_morts_2 |> filter(Year==2019),aes(y=Total_harvest),pch=23,cex=2,fill="magenta")




#segmented model with a slope of zero before the break and slope of 1 after the break
mod_fun<-function(x,psi,int){
  int+ifelse(x>psi,x-psi,0)
}

mod_fun_2<-function(par,dat,y){
  -sum(dnorm(mod_fun(dat,par[1],par[2]),y,exp(par[3]),log = TRUE))
}


seg_fit_NT<-optim(c(-2,-2,-1),mod_fun_2,dat=qlogis(pfmc_morts_2$in_river_allowed_HR[pfmc_morts_2$Sector=="NT"]),y=qlogis(pfmc_morts_2$in_river_HR[pfmc_morts_2$Sector=="NT"]))

seg_fit_T<-optim(c(-2,-2,-1),mod_fun_2,dat=qlogis(pfmc_morts_2$in_river_allowed_HR[pfmc_morts_2$Sector=="Treaty"]),y=qlogis(pfmc_morts_2$in_river_HR[pfmc_morts_2$Sector=="Treaty"]))




in_riv_pred2<-data.frame(#Allowed_in_river=rep(seq(0,100000,5000),times=1),
  in_river_allowed_HR=rep(seq(0,.4,.01),times=2),
  Sector=as.factor(rep(c("NT","Treaty"),each=41)))



# in_riv_pred$pred=plogis(predict(segmented_model,newdata=in_riv_pred))
in_riv_pred2$pred=plogis(c(mod_fun(x=qlogis(seq(0,.4,.01)),seg_fit_NT$par[1],seg_fit_NT$par[2]),mod_fun(x=qlogis(seq(0,.4,.01)),seg_fit_T$par[1],seg_fit_T$par[2])))


in_riv_pred2$ucl<-plogis(qlogis(in_riv_pred2$pred)+2*exp(ifelse(in_riv_pred2$Sector=="Treaty",seg_fit_T$par[3],seg_fit_NT$par[3])))
in_riv_pred2$lcl<-plogis(qlogis(in_riv_pred2$pred)-2*exp(ifelse(in_riv_pred2$Sector=="Treaty",seg_fit_T$par[3],seg_fit_NT$par[3])))


mod_2_plot<-in_riv_pred2 |> 
  ggplot(aes(x=in_river_allowed_HR))+geom_ribbon(aes(ymin=lcl,ymax=ucl),fill="grey")+geom_line(aes(y=pred),lwd=1.25,color="firebrick4")+geom_point(data=pfmc_morts_2,aes(y=in_river_HR),cex=1.75)+geom_abline(intercept=0,slope=1,lwd=.8,col="blue")+facet_wrap(~Sector)+ylab("In-rive HR")+xlab("Allowed in-river HR")+theme_minimal()+geom_point(data=pfmc_morts_2 |> filter(Year==2019),aes(y=in_river_HR),cex=1.75,pch=23,cex=2,fill="magenta")

gridExtra::grid.arrange(mod1_plot,mod_2_plot)


```


#### Mark-selective fisheries

The above models can be used to simulate harvest rates (including incidental mortality) on the run at large. That is the metric used in the current harvest control rule. But, harvest rates differ for wild and hatchery components due to mark selective fisheries. Three additional parameters are needed to convert harvest rates on the aggregate to harvest on the hatchery and wild components.  

- $p^\text{UM release}$ -- The proportion of unmarked fish handled in the fishery, which are released.
- $p^\text{Mark hatchery}$ --The mark rate of the hatchery return.
- $p^\text{Mort}$ -- The mortality rate of fish after being released. This is assumed to equal 0.15, which is the TAC approved rate for sport fisheries.

The joint probability that an unmarked fish that is handled in the fishery dies (is retained or is released and dies), $\phi$, is then $\phi=(1-p^\text{UM release})+(p^\text{UM release}*p^\text{Mort})$.

We also need the mark rate of the total run $p^\text{Mark total}$, which is calculated as the hatchery mark rate times the hatchery run size, divided by the total river mouth run size including natural-origin fish: 

$$p^\text{Mark total}=\frac{p^\text{Mark hatchery}N^\text{hatchery}}{\text{River mouth run size}}$$.


The expected number of fish handled $n^\text{Handle}$ that results in $n^\text{Dead}$ dead fish is then $n^\text{Handle}=n^\text{dDead}/\left(p^\text{Mark total}+(1-p^\text{Mark total})\phi\right)$. Assuming that all handled marked fish are retained, the expected number of dead marked fish is $n^\text{Dead marked}=n^\text{Handle}p^\text{Mark total}$, and the expected number of dead unmarked fish is $n^\text{Dead unmarked}=n^\text{Handle}(1-p^\text{Mark total})\phi$.

As fish are killed in this manner, the mark rate changes, because marked fish are being killed at a higher rate than unmarked fish. Therefore, the new mark rate of the run ${p^\text{mark total*}}$ must be updated as mortalities accrue, 
$$p^{\text{Mark total*}}=\frac{N*p^\text{Mark total}-n^\text{Tot dead marked}}{N-(n^\text{Tot dead marked}+n^\text{Tot dead unmarked})}$$
where $N$ is the number of fish at large prior to fishing $p^\text{mark total}$ is mark rate prior to fishing, and $n^\text{Tot dead marked}$ is the total number of marked fish mortalities. The new mark rate must then be used in the equations to calculate marked and unmarked mortalities for a given number of dead fish. The fishing mortality rate on marked ($HR^\text{marked}=n^\text{Tot dead marked}/ (N*p^\text{Mark total})$) and unmarked ($HR^\text{unmarked}=n^\text{Tot dead unmarked}/ \left(N*(1-p^\text{Mark total})\right)$) fish for a given number of total mortalities is thus calculated recursively using the above equations. I updated the mark rate of the fish at large after every 0.1% impact. 


The fishing mortality on natural-origin fish is the fishing mortality on unmarked fish and the fishing mortality on hatchery fish is the weighted average of the marked and unmarked harvest rates, where the weights are determined by the mark rate of the hatchery stock.

$$HR^\text{Hatchery}=p^\text{Mark hatchery}*HR^\text{marked}+(1-p^\text{Mark hatchery})*HR^\text{unmarked}$$


I assumed that the proportion of handled unmarked fish that will be released ($p^\text{UM release}$) in non-Treaty fisheries would be the average 2020--2023 rate (`r round(URR |> filter(Year>=2021) |> summarize(URR=mean(URR)) |> pull(URR),2)`)

```{r, fig.cap="Figure . Proportion of unmarked fish handled in all non-Treaty fisheries that were released, by year."}

# Unmarked release rates
# URR |> ggplot(aes(x=Year,y=URR))+geom_point()+geom_line()+xlim(2008,2023)+ylab("Unmarked release rate")
# 
# recent_URR<-URR |> filter(Year>=2013) |> summarize(URR=mean(URR))

internal_data$URR<-URR |> filter(Year>=2021) |> summarize(URR=mean(URR)) |> pull(URR) 

URR |> ggplot(aes(x=Year,y=URR))+geom_point()+geom_line()+xlim(2008,2023)+ylab("Unmarked release rate")+theme_minimal()+ylim(0,1)#+geom_segment(aes(x=2021,y=internal_data$URR,xend=2023,yend=internal_data$URR),color="firebrick4",lty=1,lwd=1.5)
```


I assumed that the mark rate of hatchery fish would be the average mark rate of smolt releases from brood years 2008--2021, excluding an anomalous year in 2019 (mark rate =`r round(ave_MR["mean(MR)"],2) `)


### Broodstock collection

I assume that the Methow and Wenatchee integrated programs will collect their target natural-origin broodstock, with 10% error, unless that constitues >30% of the total natural-origin escapement to that tributary. In that case, 30% of the natural-origin escapement is collected, with 10% error. The escapement goals for the Wenatchee is 310 total adults and for the Methow is 122. 

The Okanogan program has more frequently collected less than their natural-origin broodstock target of 656 adults, so I implemented a positive relationship between natural-origin escapement and natural-origin broodstock collection up to the target.



```{r broodstock_removal}


esc_dat %>% filter(year>=2012)|> dplyr::select(year,population_name ,Broodstock=NOBroodStockRemoved,NOR) %>%
  drop_na()  %>% ggplot(aes(x=(NOR),y=(Broodstock)))+geom_point()+facet_wrap(~population_name,scales="free_x")+geom_smooth(method = "lm",formula="(y)~log(x)")+xlab("Natural-origin escapement")+ylab("Natural-origin broodstock")+theme_minimal()


Ok_bs_mod<-(lm(log(NOBroodStockRemoved)~log(NOR)-1,
               data=(esc_dat %>% filter(year>=2012,population_name=="Okanogan"))))


```


### Hatchery-origin spawners

The number of hatchery-origin spawners in each population in each year was simulated as a linear function of hatchery escapement with normal error (truncated so that hatchery-origin spawners could not be <0). Each population had a unique intercept for hatchery origin spawners and a common coefficient for the effect of log-transformed hatchery-origin escapement on hatchery-origin spawners. The thinking behind log-transforming hatchery escapement is that at very high hatchery escapement, efforts would be made to keep lots of hatchery fish off of spawning grounds (e.g., with weirs or directed fisheries). There is also data support for log transforming that covariate.


```{r HOS, fig.cap="Figure. Number of hatchery origin spawners (HOS) vs hatchery escapement. The line represent the mean relationship, the shaded area is a 95% prediction interval, and points represent observations from 2010-2022."}


# HOS data for model fitting
phos_dat<-esc_dat%>% filter(!is.na(`SG No. Age 4`)) |> filter(year>=2010) |> mutate(logit_phos=qlogis(PHOS)) |> left_join((returns |> group_by(year) |> summarize(hatch_return=sum(hatchery))) |> 
                                                                                                                            drop_na())|> 
  group_by(population_name) |> 
  mutate(year_fac=as.factor(year),
         NOS_scale=scale(NOS),
         year_scale=scale(year),
         hatch_return_scale=scale(hatch_return)) |> 
  left_join(term_ER,by=c("year"="Year")) |> 
  ungroup() |> 
  mutate(hatchery_escapement=hatch_return*(1-term_M_HR ))


## diagnostic plots
# esc_dat |> ggplot(aes(x=year,y=HOS))+geom_point()+facet_wrap(~population_name)+geom_line()
# 
# 
# esc_dat |> filter(year>=2010)|> ggplot(aes(x=NOS,y=HOS))+geom_point()+facet_wrap(~population_name,scales = "free")+geom_smooth(method = "lm")
# 
# 
# phos_dat |> ggplot(aes(x=(hatchery_escapement),y=(HOS)))+geom_point()+facet_wrap(~population_name,scales = "free")+geom_smooth(method = "lm")
# 
# 
# phos_dat |> ggplot(aes(x=(NOS),y=(PHOS)))+geom_point()+facet_wrap(~population_name,scales = "free")+geom_smooth(method = "lm")

#                                             

# wen<-phos_dat |> filter(population_name=="Wenatchee")
# 
# mod<-lm((HOS)~1,data=wen)
# summary(mod)
# AIC(mod)
# 
# met<-phos_dat |> filter(population_name=="Methow")
# 
# mod<-lm((HOS)~hatchery_escapement,data=met)
# summary(mod)
# AIC(mod)
# 
# oka<-phos_dat |> filter(population_name=="Okanogan")
# 
# mod<-lm((HOS)~hatchery_escapement,data=oka)
# summary(mod)
# AIC(mod)

HOS_mod<-glmmTMB::glmmTMB((HOS)~population_name+log(hatchery_escapement)-1+diag(population_name+0|year_fac),data=phos_dat,dispformula = ~0)
# summary(HOS_mod)
# AIC(HOS_mod)

phos_dat2<-phos_dat |> mutate(pred_HOS=predict(HOS_mod,re.form=~0))|>
  left_join(tibble(population_name=c("Methow","Okanogan","Wenatchee"),resid_sd=tail( exp(HOS_mod$fit$par),3)))


phos_dat2 |> ggplot(aes(x=hatchery_escapement))+geom_ribbon(aes(ymax=pred_HOS+(1.96*resid_sd),ymin=pred_HOS-(1.96*resid_sd)),fill="gray")+geom_line(aes(y=pred_HOS))+geom_point(aes(y=HOS))+facet_wrap(~population_name,scales="free")+ylab("Hatchery-origin spawners")+xlab("Hatchery escapement")+
  scale_y_continuous(labels = scales::unit_format(suffix="K",scale = 1e-3))+
  scale_x_continuous(labels = scales::unit_format(suffix="K",scale = 1e-3))
```


Combining these modules, and initualizing the model with spawners and smolt released for brood year 2017--2022, produces a closed-loop simulation model (see diagram figure). This can be used to simmulate the outcomes of different harvest control rules on harvest, escapement, pHOS, and pNOB.

```{r internal_data}
sim_for_model<-FALSE

if(sim_for_model){
  #==========================================================================================
  # MREER
  #==========================================================================================
  
  n_sims<-n_sim<-500
  n_year<-51
  
  #these are actually logit transformed annual survivivals by age and catch year, which we will use to calculate MREER by age and brood year
  set.seed(623) 
  sim_surv_for_mod<-MARSS::MARSSsimulate(sim_surv_mod,tSteps = n_year,n_sims)$sim.data  
  
  
  
  surv_array<-array(NA,dim=c(5,55,n_sims)) #first col will be catch year 2019
  surv_array[,1:4,]<-fit.dfa.surv$ytT[,47:51] #estimated in 2019:2023
  surv_array[,5:55,]<-sim_surv_for_mod # simulated in 2024:2073
  surv_array_unscaled<-surv_array*pre_turm_surv_scales$sd+pre_turm_surv_scales$mu # rescale
  surv_array_unscaled_backtransformed<-plogis(surv_array_unscaled) #inverse logit
  for (i in 2:5){ #lead data by row to allign by brood year. after this, the first col is brood year 2017
    for ( j in 1:n_sims){
      surv_array_unscaled_backtransformed[i,,j]<-dplyr::lead(c(surv_array_unscaled_backtransformed[i,,j]),(i-1))
    }
  }
  
  #calculate MREER
  MREER_out<-apply(surv_array_unscaled_backtransformed,2:3,cumprod)
  
  dimnames(MREER_out)[1:2]<-list(age=2:6,Brood_year=2018:(2018+54))
  
  #save to list that will be saved as internal data
  internal_data$MREER_out<-MREER_out
  
  
  #==========================================================================================
  # stock recruit
  #==========================================================================================
  SR_err_fun_TMB<-function(t1=fit_rep$err2 |> tail(1) |> c(),# AR1 random effect in final year
                           n_years=50,
                           n_sims=500){
    
    # random deviates
    err<-array(t(mvtnorm::rmvnorm(n=n_years*n_sims,sigma=rick_cor)),dim=c(4,n_years,n_sims))
    innovation_sd<-marg_sd*sqrt(1-rho^2)
    ##  process error
    proc_err<-array(NA,dim=list(pops=4,years=n_years,sims=n_sims))
    proc_err[,1,]<-t1*rho + marg_sd*err[,1,]
    for (i in 2:n_years){
      proc_err[,i,]<-proc_err[,i-1,]*rho + innovation_sd*err[,i,]
    }
    
    proc_err
  }
  
  set.seed(1234)
  SR_err<-SR_err_fun_TMB(t1 = fit_rep$err2 |> tail(1) |> c(),n_years = 50, n_sims = 500)
  
  
  
  internal_data$alphas<-alpha#c(alpha[1],rep(alpha[2],3))
  # internal_data$betas<-beta
  internal_data$Rmax<-Rmax
  internal_data$SR_err<-SR_err
  internal_data$Smsy<-Smsy
  
  
  #==========================================================================================
  # age proportions
  #==========================================================================================
  set.seed(5678)
  sim_alr<-MARSS::MARSSsimulate(sim_mod,tSteps = n_year,n_sims)$sim.data
  sim_alr2<-array(sim_alr*mat_age_scales$sd+mat_age_scales$mu,dim=c(4,4,n_year,n_sims))
  sim_alr2<-exp(sim_alr2)
  sim_sum<-apply(sim_alr2,2:4,sum)
  sim_sum2<-array(rep(sim_sum,each=4),dim=c(4,4,n_year,n_sims))
  age_props<-sim_alr2/sim_sum2
  
  # 
  # age_props2<-apply(age_props,2:4,cumsum)
  # 
  # i<-2;j<-8
  # plot(age_props2[1,i,,j],type="o",ylim=c(0,1))
  # points(age_props2[2,i,,j],type="o",col="red")
  # points(age_props2[3,i,,j],type="o",col="blue")
  # points(age_props2[4,i,,j],type="o",col="green")
  # 
  # apply(age_props,1:2,quantile,.975)
  # apply(age_props,1:2,sd)
  
  
  internal_data$age_props<-age_props
  
  #==========================================================================================
  # pfmc
  #==========================================================================================
  pfmc_err<-matrix(rnorm(n_year*n_sim,0, exp(pfmc_mod_fit$par[2])),n_year,n_sim)
  
  internal_data$pfmc_err<-pfmc_err
  internal_data$PFMC_ave_prop<-pfmc_mod_fit$par[1]
  
  #==========================================================================================
  # in-river harvest
  #==========================================================================================
  ### save to internal data for model option 1
  set.seed(1112)
  in_river_err_option1<-array(NA,dim=c(2,n_year,n_sim))
  in_river_err_option1[1,,]<-rnorm(n_year*n_sim,0,exp(in_riv_mod$fit$par[4]))#treaty
  in_river_err_option1[2,,]<-rnorm(n_year*n_sim,0,exp(in_riv_mod$fit$par[3]))#non treat
  
  
  internal_data$in_river_coefs_option1<-in_riv_mod$fit$par[2:1] #treaty, NT
  internal_data$in_river_err_option1<-in_river_err_option1
  
  ### save to internal data for model option 2
  in_river_err<-array(NA,dim=c(2,n_year,n_sim))
  in_river_err[1,,]<-rnorm(n_year*n_sim,0,exp(seg_fit_T$par[3]))
  in_river_err[2,,]<-rnorm(n_year*n_sim,0,exp(seg_fit_NT$par[3]))
  
  
  internal_data$in_river_coefs<-c(seg_fit_T$par[1:2],seg_fit_NT$par[1:2])
  internal_data$in_river_err<-in_river_err
  
  #==========================================================================================
  # HOS
  #==========================================================================================
  internal_data$HOS_mod_coefs<-
    head(HOS_mod$fit$par,4) #intercepts for met, ok, wen, and shared effect of HOE
  
  set.seed(1516)
  HOS_err<-
    sapply(exp(tail(HOS_mod$fit$par,3)),function(x)rnorm(n_year*n_sim,0,x))
  
  HOS_err<-array(t(HOS_err),dim=c(3,n_year,n_sim))
  
  internal_data$HOS_err<-HOS_err
  
  
  #==========================================================================================
  # natural origin broodstock
  #==========================================================================================
  set.seed(1314)
  NOB_err<-array(exp(rnorm(n_year*n_sim*3,0,.1)),dim=c(3,n_year,n_sim)) ## assume 10% CV
  
  internal_data$NOB_err<-NOB_err
  internal_data$Ok_BS_coef<-coef(Ok_bs_mod)
  
  #==========================================================================================
  # smolt production
  #==========================================================================================
  set.seed(1819)
  smolt_err<-matrix(rnorm(n_year*n_sim,0,smolts_sd),n_year,n_sim)
  
  internal_data$smolts_mu<-smolts_mu
  internal_data$smolt_err<-smolt_err
  #==========================================================================================
  # spawners and smolts in first 6 years
  #==========================================================================================
  
  
  init_S<-esc_dat |> filter(between(year,2018,2023)) |>
    mutate(effective_spawners=NOS+HOS*pNI_bar) |> 
    dplyr::select(year,basin=population_name,effective_spawners) |>
    arrange(basin) |> pivot_wider(names_from = basin,values_from=effective_spawners) |>
    left_join(rel3 |> dplyr::select(year=brood_year,Hatchery=releases)) |>
    dplyr::select(Hatchery,Methow,Okanogan,Wenatchee)
  
  # fill missing 2022:2023 hatchery releases with mean 
  set.seed(2021)
  init_S$Hatchery[5:6]<-rep(exp(smolts_mu),2)
  
  internal_data$init_S<-init_S
  
  init_PNI<-
    esc_dat |> filter(between(year,2010,2023)) |>
    dplyr::select(year,basin=population_name,pNI) |>
    arrange(basin) |> pivot_wider(names_from = basin,values_from=pNI)
  
   internal_data$init_PNI<-init_PNI |> select(-year) |> as.matrix() |> t()
  
  
  write_internal<-TRUE
  if(write_internal){
    usethis::use_data(internal_data, overwrite = TRUE,internal = TRUE)
  }
  
  add_baselines<-TRUE
  if(add_baselines){
    sim<-pop_sim()
    sim_list<-list(hcr=seq_HCR(),perf=summarize_sim(sim,HCR="Current MA"))
    
    internal_data$`Current MA`<-sim_list
    internal_data$`No harvest`<-list(perf=summarize_sim(pop_sim(treaty_tiers = NA,treaty_rates = 0,NT_tiers=NA,NT_rates=0),HCR="No harvest"),hcr=seq_HCR(treaty_tiers = NA,treaty_rates = 0,NT_tiers=NA,NT_rates=0))
    
    #PST
    ## 85% of avg 09-15
    ave_harv<-internal_data$pfmc_morts_2 |> filter(between(Year,2009,2015)) |> select(Year, RMRS,`PFMC NT Harvest Total`,In_river_harvest,Sector) |> pivot_wider(values_from = In_river_harvest,names_from=Sector) |> mutate(ER=(Treaty+NT)/RMRS) |> summarize(ER_limit=mean(ER)*.85) |> pull(ER_limit) |> c()
    
    
    PST_HCR<-list( treaty_tiers=c(round(12143/(1-floor((ave_harv)*100)/100)),rep(NA,2)),
                   treaty_rates=c(floor((ave_harv/2)*100)/100,rep(NA,2)),
                   treaty_scalar=c(NA,1,rep(NA,1)),
                   treaty_offset=c(NA,12143,rep(NA,1)),
                   treaty_share = c(NA,.5,rep(NA,1)),
                   NT_tiers=c(round(12143/(1-floor((ave_harv)*100)/100)),rep(NA,2)),
                   NT_rates=c(floor((ave_harv/2)*100)/100,rep(NA,2)),
                   NT_scalar=c(NA,1,rep(NA,1)),
                   NT_offset=c(NA,12143,rep(NA,1)),
                   NT_share = c(NA,.5,rep(NA,1)))
    
    
    internal_data$`PST` <-list(perf=summarize_sim(do.call(pop_sim,PST_HCR),HCR="PST"),hcr=do.call(seq_HCR,PST_HCR))
    
    
    simplified_MA<-list(
      treaty_tiers=c(36250,rep(NA,2)),
      treaty_rates=c(.1,rep(NA,2)),
      treaty_scalar=c(NA,1,rep(NA,1)),
      treaty_offset=c(NA,29000,rep(NA,1)),
      treaty_share = c(NA,.5,rep(NA,1)),
      NT_tiers=c(36250,rep(NA,2)),
      NT_rates=c(.1,rep(NA,2)),
      NT_scalar=c(NA,1,rep(NA,1)),
      NT_offset=c(NA,29000,rep(NA,1)),
      NT_share = c(NA,.5,rep(NA,1)))
    
    internal_data$`Simplified MA` <-list(perf=Sumsimmer:::summarize_sim(do.call(pop_sim,simplified_MA),HCR="Simplified MA"),hcr=do.call(Sumsimmer:::seq_HCR,simplified_MA))
    
    
    
    internal_data$`No harvest`<-list(perf=summarize_sim(pop_sim(treaty_tiers = NA,treaty_rates = 0,NT_tiers=NA,NT_rates=0),HCR="No harvest"),hcr=seq_HCR(treaty_tiers = NA,treaty_rates = 0,NT_tiers=NA,NT_rates=0))
    
    
    
  }
  
  write_internal<-TRUE
  if(write_internal){
    usethis::use_data(internal_data, overwrite = TRUE,internal = TRUE)
  }
}



```



# Historical vs. simulation plots

As a check on whether the simulation model passes the red face test, I compared the 25 year simulations using the harvest control control rule, to observations from 2008-2022, when the current harvest control rules has been in effect. I wouldn't expect the simulations to match the past observations perfectly, because the past 15 years won't necessarily reflect the average state of the system. In other words, the productivity over the last 15 years (e.g, due to ocean conditions) could have been above or below average, whereas the simulations should reflect the average.

Note that when considering the outcomes of alternative harvest control rules for the next agreement, we want to compare performance metrics based on simulations. These simulations all assume the same environmental and biological conditions. Comparing to past observations would not be appropriate because those occured under a different set of environmental conditions.

```{r do_sim,cache=TRUE}
sim<-pop_sim()
```

### Harvest
```{r ave_harv_obs,fig.cap=" Quantiles of annual harvest (2.5%, 25%, 50%, 75%, and 97.5%) for both the 2008-2022 period and simulations of the 2023-2047 period. Note that the quantiles are across years, not simulations. So the lower 2.5% would represent one of the lowest-harvest years expected."}

yrs<-7:31

pfmc_morts<-
  Sumsimmer:::internal_data$pfmc_morts_2 |> select(Year,Sector,In_river_harvest) |> pivot_wider(values_from = In_river_harvest,names_from = Sector) |> left_join(internal_data$pfmc_morts_2 |> select(Year,Sector,Total_harvest) |> filter(Sector=="NT") |> select(Year,NT_total_harvest=Total_harvest)) |>  filter(between(Year,2008,2023)) |>
  `colnames<-`(c("Year","Total Treaty", "Total In-river NT","Total NT"))


harvest_quants<-data.frame(rbind(
  apply(apply(apply(sim$terminal_NT[,yrs,],2:3,sum),2,quantile,c(.025,.25,.5,.75,.975)),1,mean), # sum across populations, quantile across years, geometrtic mean across simulations
  apply(apply(apply(sim$terminal_NT[,yrs,],2:3,sum) + sim$PFMC[yrs,],2,quantile,c(.025,.25,.5,.75,.975)),1,mean),
  apply(apply(apply(sim$terminal_treaty[,yrs,],2:3,sum),2,quantile,c(.025,.25,.5,.75,.975)),1,mean)
))
colnames(harvest_quants)<-c("min","LQI","med","UQI","max")
harvest_quants$Sector<-c("NT_in_river","NT_plus_PFMC","Treaty")

harvest_plot_dat<-  harvest_quants |> mutate(Type="Simulated 2023-2047")|> bind_rows(
  rbind(
    quantile(head(pfmc_morts$`Total In-river NT`,-1),c(.025,.25,.5,.75,.975)),
    quantile(head(pfmc_morts$`Total NT`,-1),c(.025,.25,.5,.75,.975)),
    quantile(head(pfmc_morts$`Total Treaty`,-1,c(.025,.25,.5,.75,.975)))
  ) |> `colnames<-`(c("min","LQI","med","UQI","max")) |> as_tibble()|> mutate(Sector=c("NT_in_river","NT_plus_PFMC","Treaty"),Type="Observed 2008-2022")
)


harvest_plot_dat |> ggplot(aes(x = Sector, ymin = `min`, lower = `LQI`, middle = `med`, upper = `UQI`, ymax = `max`,fill=Type))+geom_boxplot(stat="identity")+ylab("Harvest")+theme_minimal()+scale_fill_brewer(palette="Dark2")+xlab("")



```


```{r, fig.cap="Figure. Estimates of 2008-2022 in-river harvest (bars), median of simulated future harvest trajectories (thick black line), random individual simulated trajectory (thin black line), and 95% prediction interval of future harvest (shaded area)."}
plot_harvest_trajectory(harv_traj_dat_fun(sim))
```


### Harvest sharing ratio
```{r ratio_obs, fig.cap="Figure. uantiles of the ratio of Treaty and non-Treaty harvest (inclusive of ocean PFMC AEQ) for both the 2008-2022 period and simulations of the 2023-2047 period."}
## average ratio of treaty to non-treaty
### quantiles of across-year mean
Sector_ratio<-data.frame(rbind(
  # quantile(apply(apply(sim$terminal_treaty[,yrs,],2:3,sum)/apply(sim$terminal_NT[,yrs,],2:3,sum),2,mean)),
  quantile(apply(apply(sim$terminal_treaty[,yrs,],2:3,sum)/(apply(sim$terminal_NT[,yrs,],2:3,sum)+ sim$PFMC[yrs,]),2,mean))
))
colnames(Sector_ratio)<-c("min","LQI","med","UQI","max")
Sector_ratio$ratio<-c("Treaty:NT total")

Sector_ratio_plot_dat<- Sector_ratio |> mutate(Type="Simulated\n2023-2047") |>
  bind_rows(
    
    rbind(
      # quantile(head(pfmc_morts$`Total Treaty`,-1)/head(pfmc_morts$`Total In-river NT`,-1)),
      quantile(head(pfmc_morts$`Total Treaty`,-1)/head(pfmc_morts$`Total NT`,-1))
    )  |> `colnames<-`(c("min","LQI","med","UQI","max")) |> as_tibble()|> mutate(ratio=c("Treaty:NT total"),Type="Observed\n2008-2022")
  )



Sector_ratio_plot_dat |> ggplot(aes(x = Type, ymin = `min`, lower = `LQI`, middle = `med`, upper = `UQI`, ymax = `max`))+geom_boxplot(stat="identity")+ylab("Ratio of treaty : non-treaty harvest\n(includes PFMC AEQ)")+geom_hline(yintercept =1,lty=2)+theme_minimal()+xlab("")
## harvest variability (year to year)
```

### River mouth run size
```{r RMRS, fig.cap="Figure. Quantiles of river mouth run size for both the 2008-2022 period and simulations of the 2023-2047 period."}


#River mouth run size
sim$returns[,yrs,] |> apply(2:3,sum) |> apply(2,quantile,c(.025,.25,.5,.75,.975)) |> apply(1,mean) |> bind_rows(
  
  internal_data$pfmc_morts_2 |> filter(between(Year,2008,2022)) |> filter(Sector=="Treaty") |>
    summarise(as_tibble_row(quantile(RMRS,c(.025,.25,.5,.75,.975))))
) |> 
  `colnames<-`(c("min","LQI","med","UQI","max"))|> 
  mutate(Type=c("Simulated","Observed")) |> 
  ggplot(aes(x = Type, ymin = `min`, lower = `LQI`, middle = `med`, upper = `UQI`, ymax = `max`))+geom_boxplot(stat="identity")+ylab("River mouth run size")+theme_minimal()+scale_fill_brewer(palette="Dark2")+xlab("")
```


### Natural-origin escapement

Note that non-treaty fisheries have become much more mark selective through time, which is reflected in simulations of the future.


```{r escapement_plot, fig.cap="Figure. Quantiles of natural-origin escapement (spawners and broodstock) for both the 2008-2022 period and simulations of the 2023-2047 period."}

## escapement
esc_plot_dat<-ave_quants(sim$NOS+sim$NOB,rnames="River") |> mutate(Type="Simulated") |> filter(River!="Total") |> bind_rows(
  
  internal_data$esc_dat %>% filter(!is.na(`SG No. Age 4`),between(year,2008,2022)) |> select(year,population_name ,Spawn=NOS,Broodstock=NOBroodStockRemoved) %>%
    drop_na() |> mutate(escapement=Spawn+Broodstock) |> group_by(population_name) |> summarise(as_tibble_row(quantile(escapement,c(.025,.25,.5,.75,.975)))) |> 
    `colnames<-`(c("River","min","LQI","med","UQI","max")) |> 
    mutate(Type="Observed")
)

esc_plot_dat |> ggplot(aes(x = River, ymin = `min`, lower = `LQI`, middle = `med`, upper = `UQI`, ymax = `max`,fill=Type))+geom_boxplot(stat="identity")+ylab("Annual Escapement")+theme_minimal()+scale_fill_brewer(palette="Dark2")+xlab("")

```



```{r fig.cap="Figure. Estimates of 2008-2022 natural-origin escapement (bars), median of simulated future harvest trajectories (thick black line), random individual simulated trajectory (thin black line), and 95% prediction interval of future harvest (shaded area)."}

plot_esc_trajectory( esc_traj_data_fun(sim))

```


### Proportion of hatchery-origin spawners (pHOS)  

```{r phos_fig, fig.cap="Figure. Quantiles of pHOS for both the 2008-2022 period and simulations of the 2023-2047 period."}

## Average pHOS
sim_pHOS<-1-(sim$NOS[,yrs,]/sim$S[-1,yrs,])



apply(sim_pHOS,c(1,3),quantile,c(.025,.25,.5,.75,.975)) |> apply(1:2,mean) |> 
  t() |> as.data.frame() |> rownames_to_column("River") |> mutate(Type="Simulated") |> 
  bind_rows(
    Sumsimmer:::internal_data$esc_dat %>% filter(between(year,2008,2022),population_name!="Hatchery") |> 
      group_by(population_name) |> summarise(as_tibble_row(quantile(PHOS,c(.025,.25,.5,.75,.975)))) |> rename("River"="population_name") |> mutate(Type="Observed")
  )|> 
  `colnames<-`(c("River","min","LQI","med","UQI","max","Type"))|> 
  ggplot(aes(x = River, ymin = `min`, lower = `LQI`, middle = `med`, upper = `UQI`, ymax = `max`,fill=Type))+geom_boxplot(stat="identity")+ylab("pHOS")+theme_minimal()+scale_fill_brewer(palette="Dark2") + ylim(0,1)+xlab("")



```


